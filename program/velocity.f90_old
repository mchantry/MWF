!*************************************************************************
!
!
!*************************************************************************
#include "../parallel.h"
module velocity
  !*************************************************************************
  use mpif
  use variables
  use transform
  !   use timestep
  implicit none
  save
  
  type (phys) :: vel_p
  type (mpt)  :: vel_c,vel_c2,vel_onl,vel_nl,lhs,rhs
  logical :: nst
  
contains
  
  subroutine vel_TS()
    
    _loop_kmn_vars
    
    call vel_nonlinear()
    if (nst) then
       call var_mpt_copy(vel_nl,vel_onl)
       nst = .false.
    end if
    _loop_kmn_begin
    vel_c2%Re(k,m,n)=rhs%Re(k,m,n)*vel_c%Re(k,m,n)
    vel_c2%Im(k,m,n)=rhs%Re(k,m,n)*vel_c%Im(k,m,n)
    vel_c2%Re(k,m,n)=vel_c2%Re(k,m,n) + d_dt/2d0*(3d0*vel_nl%Re(k,m,n)-vel_onl%Re(k,m,n))
    vel_c2%Im(k,m,n)=vel_c2%Im(k,m,n) + d_dt/2d0*(3d0*vel_nl%Im(k,m,n)-vel_onl%Im(k,m,n))
    vel_c2%Re(k,m,n)=vel_c2%Re(k,m,n) / lhs%Re(k,m,n)
    vel_c2%Im(k,m,n)=vel_c2%Im(k,m,n) / lhs%Re(k,m,n)
    _loop_kmn_end
    if (var_N%pH0 == 0) then
       vel_c2%Re(1,0,0)=0d0
    end if
    call var_mpt_copy(vel_nl,vel_onl)
    call var_mpt_copy(vel_c2,vel_c)
    
  end subroutine vel_TS
 
  subroutine vel_precompute()
   
    call var_mpt_init(vel_c)
    call var_mpt_init(vel_nl)
    call var_LHSRHS(lhs,rhs)
    nst = .true.

  end subroutine vel_precompute

  subroutine vel_imposesym()

    if (s_reflect) call var_reflect(vel_c)

  end subroutine vel_imposesym

  subroutine vel_addlam(u)
    type (spec), intent(inout) :: u
    if (var_N%pH0 == 0) then 
       u%Re(2,0,0) = u%Re(2,0,0) + dcos(d_theta)
       u%Re(9,0,0) = u%Re(9,0,0) + dsin(d_theta)
    end if
  end subroutine vel_addlam
  
  subroutine vel_mpt2phys(u,p)
    type(mpt), intent(in) :: u
    type(phys), intent(out) :: p
    type(spec) :: tmp
    call var_mpt2spec(u,tmp)
    call tra_spec2phys(tmp,p)
  end subroutine vel_mpt2phys
  
  subroutine vel_nonlinear()
    type (spec) :: u,ux,uz
    type (phys) :: p,px,pz,ans
    _loop_mn_vars
    
    call var_mpt2spec(vel_c,u)
    call vel_addlam(u)
    call var_spec_grad(u,ux,uz)
    call tra_spec2phys(u,p)
    call tra_spec2phys(ux,px)
    call tra_spec2phys(uz,pz)
    
    do m = 0, var_M%pH1
       do n = 0,i_N1
          ans%Re(:,n,m)=udotgradu(p%Re(:,n,m),px%Re(:,n,m),pz%Re(:,n,m))
       end do
    end do
    
    call tra_phys2spec(ans,u)
    call var_spec2mpt(u,vel_nl)
    
  end subroutine vel_nonlinear
   
  function nluw(u,w) result(ans)
    double precision :: ans(0:i_K1)
    double precision,intent(in) :: u(0:i_K1),w(0:i_K1)
    ans(0)=u(0)*w(0) + (u(1)*w(1))/2 + (u(2)*w(2))/2 + (u(3)*w(3))/2
    ans(1)=u(0)*w(1) + u(1)*w(0) - (u(1)*w(2))/2 - (u(2)*w(1))/2 + (u(2)*w(3))/2 + (u(3)*w(2))/2	
    ans(2)=u(0)*w(2) - (u(1)*w(1))/2 + u(2)*w(0) + (u(1)*w(3))/2 + (u(3)*w(1))/2
    ans(3)=u(0)*w(3) + (u(1)*w(2))/2 + (u(2)*w(1))/2 + u(3)*w(0)
    RETURN
  end function nluw

  function nluyv(u,v) result(ans)
    double precision :: ans(0:i_K1)
    double precision,intent(in) :: u(0:i_K1),v(1:i_K1)
    ans(0)=(d_beta*u(1)*v(1))/2 - d_beta*u(2)*v(2) + (3*d_beta*u(3)*v(3))/2
    ans(1)=(d_beta*u(1)*v(2))/2 - d_beta*u(2)*v(1) + d_beta*u(2)*v(3) - (3*d_beta*u(3)*v(2))/2
    ans(2)=(d_beta*u(1)*v(1))/2 + (d_beta*u(1)*v(3))/2 + (3*d_beta*u(3)*v(1))/2
    ans(3)=(d_beta*u(1)*v(2))/2 - d_beta*u(2)*v(1)
    RETURN
  end function nluyv
  
  function nluv(u,v) result(ans)
    double precision :: ans(1:i_K1)
    double precision,intent(in) :: u(0:i_K1),v(1:i_K1)
    ans(1)=u(0)*v(1) + (u(1)*v(2))/2 + (u(2)*v(1))/2 + (u(2)*v(3))/2 + (u(3)*v(2))/2
    ans(2)=u(0)*v(2) + (u(1)*v(1))/2 - (u(1)*v(3))/2 + (u(3)*v(1))/2
    ans(3)=u(0)*v(3) - (u(1)*v(2))/2 + (u(2)*v(1))/2
  end function nluv
  
  function nlvvy(v) result(ans)
    double precision :: ans(1:i_K1)
    double precision,intent(in) :: v(1:i_K1)
    ans(1)=(d_beta*v(1)*v(2))/2 - (d_beta*v(2)*v(3))/2
    ans(2)=- (d_beta*v(1)**2)/2 - d_beta*v(1)*v(3)
    ans(3)=(3*d_beta*v(1)*v(2))/2
  end function nlvvy
  
  function nlvv(v) result(ans)
    double precision :: ans(0:i_K1)
    double precision,intent(in) :: v(1:i_K1)
    ans(0)=v(1)**2/2 + v(2)**2/2 + v(3)**2/2
    ans(1)=v(1)*v(2) - v(2)*v(3)
    ans(2)=v(1)**2/2 + v(3)*v(1)
    ans(3)=v(1)*v(2)
  end function nlvv
  
  function udotgradu(u,ux,uz) result(ans)
    double precision :: ans(i_KK)
    double precision,intent(in) :: u(i_KK),ux(i_KK),uz(i_KK)
    ans(1:4)= nluw(u(1:4),ux(1:4)) + nluyv(u(1:4),u(5:7)) + nluw(u(8:11),uz(1:4))
    ans(5:7)= nluv(u(1:4),ux(5:7)) + nlvvy(u(5:7))        + nluv(u(8:11),uz(5:7))
    ans(8:11)=nluw(u(1:4),ux(8:11))+ nluyv(u(8:11),u(5:7))+ nluw(u(8:11),uz(8:11))
  end function udotgradu
  
  function epos(u) result(e)
    double precision :: e
    double precision,intent(in) :: u(11)
    double precision :: udotu(11)
    
    udotu(1:4) = nluw(u(1:4),u(1:4))
    udotu(4:7) = nlvv(u(5:7))
    udotu(8:11)= nluw(u(8:11),u(8:11))
    e=udotu(1)+udotu(4)+udotu(8)
  end function epos

  subroutine vel_energy(a,e)
    type (phys), intent(in) :: a
    double precision, intent(out) :: e
    double precision :: e_
    _loop_mn_vars
    e=0
    _loop_phy_begin
    !    print*, epos(a%Re(:,m,n))
    e = e + epos(a%Re(:,n,m))
    _loop_mn_end
#ifdef _MPI
    call mpi_allreduce( e, e_, 1, mpi_double_precision,  &
         mpi_sum, mpi_comm_world, mpi_er)
    if(mpi_rnk/=0) return
    e = e_
#endif
    e = e * d_alpha * d_beta /( 4 * d_PI * d_PI * i_3M * i_3N) 
  end subroutine vel_energy

  subroutine vel_history(V,y_space,ans)
    
    type(phys), intent(in) :: V
    double precision, intent(out) :: ans(4,i_H)
    integer :: j,ji
    double precision,intent(in) :: y_space
    
    if(mpi_rnk/=0) return 
    do j=1,i_H
       ji=int((j-1)*i_N/i_H)+1
       ans(1,j)=ji*d_Lz/i_N
       ans(2,j)=( V%Re(1,ji,0) &
            +dsin(    d_beta*y_space)*V%Re(2,ji,0) &
            +dcos(2d0*d_beta*y_space)*V%Re(3,ji,0) &
            +dsin(3d0*d_beta*y_space)*V%Re(4,ji,0))
       ans(3,j)=( dcos(    d_beta*y_space)*V%Re(5,ji,0) &
            +dsin(2d0*d_beta*y_space)*V%Re(6,ji,0) &
            +dcos(3d0*d_beta*y_space)*V%Re(7,ji,0))
       ans(4,j)=( V%Re(8,ji,0) &
            +dsin(    d_beta*y_space)*V%Re(9,ji,0) &
            +dcos(2d0*d_beta*y_space)*V%Re(10,ji,0) &
            +dsin(3d0*d_beta*y_space)*V%Re(11,ji,0))
    end do
    
  end subroutine vel_history

  double precision function velU(V,y) 
    double precision, intent(in) :: V(i_KK),y
    velU= V(1) &
         +dsin(d_beta*y) * V(2) &
         +dcos(2d0*d_beta*y) * V(3)&
         +dsin(3d0*d_beta*y) * V(4)
    return
  end function velU
  
  double precision function velW(V,y)
    double precision, intent(in) :: V(i_KK),y
    velW = V(8)&
         +dsin(d_beta*y) * V(9)&
         +dcos(2d0*d_beta*y) * V(10)&
         +dsin(3d0*d_beta*y) * V(11)
    return
  end function velW

  double precision function velV(V,y)
    double precision, intent(in) :: V(i_KK),y
    velV= dcos(d_beta*y) * V(5)&
         +dsin(2d0*d_beta*y) * V(6)&
         +dcos(3d0*d_beta*y) * V(7)
    return
  end function velV

end module velocity

